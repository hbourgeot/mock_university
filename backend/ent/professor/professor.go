// Code generated by ent, DO NOT EDIT.

package professor

import (
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the professor type in the database.
	Label = "professor"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldIdentityCard holds the string denoting the identity_card field in the database.
	FieldIdentityCard = "identity_card"
	// FieldBirthDate holds the string denoting the birth_date field in the database.
	FieldBirthDate = "birth_date"
	// FieldPhone holds the string denoting the phone field in the database.
	FieldPhone = "phone"
	// FieldAddress holds the string denoting the address field in the database.
	FieldAddress = "address"
	// EdgeUser holds the string denoting the user edge name in mutations.
	EdgeUser = "user"
	// EdgeBoss holds the string denoting the boss edge name in mutations.
	EdgeBoss = "boss"
	// EdgeSubordinates holds the string denoting the subordinates edge name in mutations.
	EdgeSubordinates = "subordinates"
	// EdgeSubjects holds the string denoting the subjects edge name in mutations.
	EdgeSubjects = "subjects"
	// EdgeCareers holds the string denoting the careers edge name in mutations.
	EdgeCareers = "careers"
	// Table holds the table name of the professor in the database.
	Table = "professors"
	// UserTable is the table that holds the user relation/edge.
	UserTable = "professors"
	// UserInverseTable is the table name for the Users entity.
	// It exists in this package in order to avoid circular dependency with the "users" package.
	UserInverseTable = "users"
	// UserColumn is the table column denoting the user relation/edge.
	UserColumn = "professor_user"
	// BossTable is the table that holds the boss relation/edge.
	BossTable = "professors"
	// BossColumn is the table column denoting the boss relation/edge.
	BossColumn = "professor_subordinates"
	// SubordinatesTable is the table that holds the subordinates relation/edge.
	SubordinatesTable = "professors"
	// SubordinatesColumn is the table column denoting the subordinates relation/edge.
	SubordinatesColumn = "professor_subordinates"
	// SubjectsTable is the table that holds the subjects relation/edge. The primary key declared below.
	SubjectsTable = "subject_professor"
	// SubjectsInverseTable is the table name for the Subject entity.
	// It exists in this package in order to avoid circular dependency with the "subject" package.
	SubjectsInverseTable = "subjects"
	// CareersTable is the table that holds the careers relation/edge.
	CareersTable = "professors"
	// CareersInverseTable is the table name for the Careers entity.
	// It exists in this package in order to avoid circular dependency with the "careers" package.
	CareersInverseTable = "careers"
	// CareersColumn is the table column denoting the careers relation/edge.
	CareersColumn = "careers_leader"
)

// Columns holds all SQL columns for professor fields.
var Columns = []string{
	FieldID,
	FieldIdentityCard,
	FieldBirthDate,
	FieldPhone,
	FieldAddress,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "professors"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"careers_leader",
	"professor_user",
	"professor_subordinates",
}

var (
	// SubjectsPrimaryKey and SubjectsColumn2 are the table columns denoting the
	// primary key for the subjects relation (M2M).
	SubjectsPrimaryKey = []string{"subject_id", "professor_id"}
)

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

var (
	// IdentityCardValidator is a validator for the "identity_card" field. It is called by the builders before save.
	IdentityCardValidator func(string) error
	// PhoneValidator is a validator for the "phone" field. It is called by the builders before save.
	PhoneValidator func(string) error
	// AddressValidator is a validator for the "address" field. It is called by the builders before save.
	AddressValidator func(string) error
)

// OrderOption defines the ordering options for the Professor queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByIdentityCard orders the results by the identity_card field.
func ByIdentityCard(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldIdentityCard, opts...).ToFunc()
}

// ByBirthDate orders the results by the birth_date field.
func ByBirthDate(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldBirthDate, opts...).ToFunc()
}

// ByPhone orders the results by the phone field.
func ByPhone(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldPhone, opts...).ToFunc()
}

// ByAddress orders the results by the address field.
func ByAddress(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAddress, opts...).ToFunc()
}

// ByUserField orders the results by user field.
func ByUserField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newUserStep(), sql.OrderByField(field, opts...))
	}
}

// ByBossField orders the results by boss field.
func ByBossField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newBossStep(), sql.OrderByField(field, opts...))
	}
}

// BySubordinatesCount orders the results by subordinates count.
func BySubordinatesCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newSubordinatesStep(), opts...)
	}
}

// BySubordinates orders the results by subordinates terms.
func BySubordinates(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newSubordinatesStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// BySubjectsCount orders the results by subjects count.
func BySubjectsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newSubjectsStep(), opts...)
	}
}

// BySubjects orders the results by subjects terms.
func BySubjects(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newSubjectsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByCareersField orders the results by careers field.
func ByCareersField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCareersStep(), sql.OrderByField(field, opts...))
	}
}
func newUserStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(UserInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, UserTable, UserColumn),
	)
}
func newBossStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(Table, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, BossTable, BossColumn),
	)
}
func newSubordinatesStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(Table, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, SubordinatesTable, SubordinatesColumn),
	)
}
func newSubjectsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(SubjectsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2M, true, SubjectsTable, SubjectsPrimaryKey...),
	)
}
func newCareersStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CareersInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, true, CareersTable, CareersColumn),
	)
}
